\documentclass[a4paper]{ctexart}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{array}
\usepackage{cite}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{pythonhighlight}
\newcommand{\upcitep}[1]{\textsuperscript{\textsuperscript{\citep{#1}}}}



\begin{document}
%队伍编号及题号
\thispagestyle{empty} % 当前页不显示页码
\setlength{\tabcolsep}{20mm}{
\begin{center}
\begin{tabular}{|c|c|}
    \hline
    队伍编号 & 904078 \\
    \hline
    题号 & (D) \\
    \hline
\end{tabular}
\end{center}}

\noindent\rule[0.25\baselineskip]{\textwidth}{1pt}

\begin{center}
\huge 钢水脱氧合金化配料方案优化
\end{center}

%\title{论文题目}  %大括号里填写标题
%\author{张三}  %大括号里填写作者姓名
%\date{\today}    %大括号里填写\today会自动生成当前的日期
%\maketitle     %我们写了以上内容以后一定要添加这个，制作标题，否则上面的内容都是无效的。

% 摘要
\begin{abstract}         %摘要部分
\small 本文基于SPSS，python中的sklearn，利用相关性分析，均值缺失值替换，多重插值缺失值替换等方法进行数据处理和分析，建立了以线性回归，支持向量回归为基础的预测模型，并以SLSQP等方法来求解约束最优化问题，探讨了对脱氧合金化环节中元素收得率的预测方法；并优化了投入的不同合金的数量，解决了在保证钢水质量符合国家标准的情况下最大限度降低成本，并增大元素收得率的问题。

	在问题1中，将问题划分为三个步骤。首先对数据进行均值替换，多重插值方法对数据缺失值处理；接着利用处理后的数据中的转炉终点元素含量，钢水净重，连铸正样元素含量以及加入合金配料重量及各配料元素重量百分比进行元素收得率计算，在计算过程中还要根据一些先验知识如收得率范围等剔除一些异常样本。最后进行收得率主要影响因素分析，主要方法是通过SPSS工具对所求出的元素收得率和各转炉终点属性以及加入合金配料等变量进行相关性分析，计算出皮尔逊相关系数以及肯德尔相关系数来分析元素收得率和各变量间的相关性，最终发现C元素收得率的主要影响因素有转炉终点温度，转炉终点C，转炉终点Mn，钢水净重，以及加入合金中的低铝硅铁，钒氮合金(进口)，钒铁(FeV50-B)，硅铝钙，硅铝合金FeAl30Si25，硅铁(合格块)，锰硅合金FeMn68Si18(合格块)，硅钙碳脱氧剂，而Mn元素收得率的主要影响因素有转炉终点Mn，转炉终点P，钢水净重，氮化钒铁FeV55N11-A，钒氮合金(进口)，硅铝钙，硅铝合金FeAl30Si25，硅铝锰合金球，硅钙碳脱氧剂，碳化硅(55\%)，锰硅合金FeMn68Si18(合格块)，硅铁FeSi75-B，硅锰面（硅锰渣）。

	在问题2中，我们首先识别出此模型的本质是一个回归模型；于是我们运用了5种不同的回归模型，即随机森林回归，梯度增强回归，多层感知机模型，线性回归和线性支持向量回归模型，以题中所给数据做为样本数据，元素收得率作为模型输出，建立不同的预测模型。通过对与不同模型的基于交叉验证的评分，我们找出了最适合预测元素收得率的模型；并将此模型运用在接下来的优化过程中。

	在问题3中，通过建立以最小化成本，最大化元素收得率为目标的函数，以满足脱氧合金化后钢水各元素含量符合国家标准为主要约束条件的有约束的最优化模型，并使用SLSQP，拉格朗日乘子法等方法进行求解，我们最终得到了不同输入样本的预测收得率，并得到了对应的成本；经过此步，我们还得到了优化后的合金配料加入方案，和优化后的成本；通过对比优化前后的元素收得率与成本，我们发现我们的优化模型可以达到增大收得率的同时减小成本的目的。

	在问题4中，从数据收集处理重要性，建立数学模型来进行计算机自动配料，以提高生产力，降低成本，保护环境等不同的方面，给炼钢厂领导写一份建议信来阐述整个论文写作以及建模过程的感悟。

\end{abstract}
关键词：钢铁脱氧合金化，元素收得率预测，合金化自动配料，线性回归，支持向量回归

\newpage
%目录页
\thispagestyle{empty} % 当前页不显示页码
\tableofcontents

\newpage
\pagestyle{plain}       %没有页眉，页脚中部放置页码
\setcounter{page}{1}
\pagenumbering{arabic}  %阿拉伯数字
% 第一部分
\section{问题重述}
\subsection{问题背景}
众所周知，要想炼出好钢，在炼钢过程中的脱氧合金化则是钢铁冶炼中的重要工艺环节。炼出不同性能的钢种，则在熔炼结束时需加入不同数量、不同种类的合金，诸如：锰（Mn）、硫（P）、硅（Si）等，最终使得成品钢在某些物理性能上达到特定的要求。伴随着世界范围内钢铁行业中高附加值钢种产量的不断提高，面对的问题也随之即来：如何通过历史数据对脱氧合金化环节建立数学模型，在线预测并优化投入合金的的种类和数量，在保证钢水质量的同时最大限度的降低合金钢的成本。
\subsection{问题的提出}
随着社会发展越来越快，显然依靠传统的计算合金加入量的方法也无法满足需求了，所以我们一数学建模的方式解决下面问题：

1.钢水脱氧合金化主要关注C、Mn、S、P、Si五种元素的含量，请根据附件计算C、Mn两种元素历史收得率，并分析影响其收得率的主要因素。

2.在问题1的基础上，构建数学模型，对C、Mn两种元素的收得率进行预测，并进一步改进模型及其算法，尽可能提高这两种元素的预测准确率。

3.不同合金材料的价格不同，其选择直接影响钢水脱氧合金的成本。请根据问题2中的合金收得率的预测结果及附件，建立数学模型，实现钢水脱氧合金化成本额优化计算，并给出配料方案。

4.根据研究结果，给炼钢厂领导写一份建议信。


% 第二部分--符号说明
\newpage
\section{符号说明}
\begin{table}[htbp]
\begin{tabular}{cc}
\hline
    符号 & 含义\\
    \hline
    $ ID $ & 钢号 \\
    $ R_c $ & C收得率 \\
    $ R_{Mn} $ & Mn收得率 \\
    $ x_1 $ & 转炉终点温度 \\
    $ x_2 $ & 转炉终点C \\
    $ x_3 $ & 转炉终点Mn \\
    $ x_4 $ & 转炉终点S \\
    $ x_5 $ & 转炉终点P \\
    $ x_6 $ & 转炉终点Si \\
    $ x_7 $ & 钢水净重 \\
    $ x_8 $ & 连铸正样C \\
    $ x_9 $ & 连铸正样Mn \\
    $ x_{10} $ & 氮化钒铁FeV55N11-A \\
    $ x_{11} $ & 低铝硅铁 \\
    $ x_{12} $ & 钒氮合金(进口) \\
    $ x_{13} $ & 钒铁(FeV50-A) \\
    $ x_{14} $ & 钒铁(FeV50-B) \\
    $ x_{15} $ & 硅铝钙 \\
    $ x_{16} $ & 硅铝合金FeAl30Si25 \\
    $ x_{17} $ & 硅铝锰合金球 \\
    $ x_{18} $ & 硅锰面（硅锰渣） \\
    $ x_{19} $ & 硅铁(合格块) \\
    $ x_{20} $ & 硅铁FeSi75-B \\
    \hline
\end{tabular}
\caption{所用参数}
\end{table}

\begin{table}[htbp]
\begin{tabular}{cc}
\hline
    符号 & 含义\\
    \hline
    $ x_{21} $ & 石油焦增碳剂 \\
    $ x_{22} $ & 锰硅合金FeMn64Si27(合格块) \\
    $ x_{23} $ & 锰硅合金FeMn68Si18(合格块) \\
    $ x_{24}$ & 碳化硅(55\%)  \\
    $ x_{25} $ & 硅钙碳脱氧剂\\
    $ y_{i}^j $ & 第i原料对应j元素重量百分比 \\
    $ M $ & 输入样本钢水脱氧合金化优化成本 \\
    $ B_{ID}^x $ & 钢号为ID的x元素的标准含量 \\
    $ m_i $ & 第i项原料的成本价 \\
    $\lambda_1, \lambda_2$ & 权重参数 \\
    $  max_i$ & 对应合金原料的加入最大值 \\
    \hline
\end{tabular}
\caption{所用参数}
\end{table}

\newpage
% 第三部分--模型假设
\section{原理概述}
\subsection{线性回归}
在统计学中，线性回归(Linear Regression)是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归,大于一个自变量情况的叫做多元回归。\cite{bibitem1} 而我们建模过程中用到模型是多线性回归。下面就是线性回归的公式： \\
\begin{center}
$ h_\theta (x)=\theta_0 x_0+\theta_1 x_1+...+\theta_n x_n $ \\
\end{center}
简化形式：\\
\begin{center}
$ h_\theta(x)=\theta^TX $
\end{center}
其中X，$\theta$ 都是一个n阶向量。 \\

\setlength{\parindent}{2em} 因为我们用到了多变量线性回归，所以分析过程中必然有多个自变量：而每个变量所代表的的含义也在表格中阐述了。 \\

\subsection{线性支持向量回归(SVR)}
给出训练向量$x_i \in R^P, i=1,...,n$和向量$\vec y \in R^n \varepsilon - SVR$解决以下任何问题：\cite{bibitem2}
\begin{equation}
\begin{aligned}
&min_{\omega,b,\zeta,\zeta^*}\frac{1}{2}\omega^T\omega+C\sum_{i=1}^n(\varepsilon+\varepsilon^*)\\
&subject\quad  to\quad  y_i\omega^T\phi(x_i)-b \le \varepsilon + \zeta_i,\\
&\omega^T\phi(x_i)+b-y_i\le\varepsilon+\zeta_i^*,\\
&\zeta,\zeta^*\ge0,i=1,...,n  \\
\end{aligned}
\end{equation}

它的对偶函数：
\begin{equation}
\begin{aligned}
&min_{\alpha,\alpha^*}\frac{1}{2}(\alpha-\alpha^*)TQ(\alpha-\alpha^*)+\varepsilon e^T(\alpha,\alpha^*)-\vec y^T(\alpha, \alpha^*) \\
&subject \quad to \quad e^T(\alpha, \alpha^*)=0  \\
&0 \le \alpha_i,\alpha_i^*\le C,i=1,...,n \\
\end{aligned}
\end{equation}

其中e是全1向量，C>0是上届限，Q是一个n*n的半正定矩阵，$Q_{ij}\equiv K(x_i,x_j)=\omega(x_i)^T\omega(x_j)$是内核。这里的训练量是显示的被$\omega$ 函数映射为更高维的空间。

决策函数：

\begin{align}
\sum_{i=1}^n(\alpha_i,\alpha_i^*)K(x_i,x)+\rho  \\
\end{align}

\subsection{拉格朗日乘子法}
拉格朗日乘子法(Lagrange multipliers)是一种寻找多元函数在一组约束下的极值的方法。用过引入拉格朗日乘子，可以将d个变量与k个约束条件的最优化问题转化为具有$d+k$个变量的无约束优化问题求解。\cite{bibitem3}

引入拉格朗日乘子 $\vec \lambda=(\lambda_1,...,\lambda_m)^T$和$\mu=(\mu_1,...,\mu_n)^T$，相应的拉格朗日函数为：

$ L(\vec x, \vec \lambda,\vec \mu)=f(\vec x)+\sum_{i=1}^m\lambda_ih_i(\vec x)+\sum_{j=1}^n\mu_jg_j(\vec x) $ \\

有不等式约束条件引入的KKT条件（j=1,2,...,n）为：

\begin{equation}
\left\{
\begin{aligned}
g_j(\vec x) & = & 0; \\
\mu_j & = & 0; \\
\mu_jg_j(\vec x) & = & 0.
\end{aligned}
\right.
\end{equation}

拉格朗日”对偶函数“(dual function)$\Gamma:R\times R\mapsto R$定义为：

\begin{equation}
\begin{aligned}
\Gamma(\vec \lambda, \vec \mu) &= inf_{x\in D}L(\vec x, \vec \lambda,\vec \mu)  \\
&=inf_{x\in D}(f(\vec x)+\sum_{i=1}^m\lambda_ih_i(\vec x)+\sum_{j=1}^n\mu_jg_j(\vec x))
\end{aligned}
\end{equation}

\newpage
% 第四部分--对问题的求解
\section{模型的建立与求解}
\subsection{问题一}
    \subsubsection{问题分析}
    附件一中包含了炉号，钢种，钢号等分类属性，转炉终点属性（即脱氧合金化前的各种属性），加入不同合金的重量，以及连铸正样属性（即脱氧合金化后的各种属性）。要计算C，Mn两种元素的历史收得率，而收得率的定义为脱氧合金化过程中被钢水吸收的元素重量与加入该元素总重量之比。因此在计算这两种元素收得率的过程中，要用到转炉终点C，转炉终点Mn，钢水净重，连铸正样C，连铸正样Mn，以及加入的各种合金的重量，还有附件二中关于各合金中元素成分重量百分比的数据。

	  由于数据的限制，所以在计算的过程中，我们假设加入原料前后钢水的净重没有发生变化，这样才能利用连铸正样和转炉终点的差值计算出该元素在钢水中增加的百分比，然后乘以钢水净重得到脱氧合金化过程中钢水吸收的元素重量；接着就是利用加入的合金料的重量乘以该合金料对应的元素重量百分比，得到加入该元素的总重量。两者相比求出元素收得率。

	  另外，通过对附件一中的数据进行分析，发现在许多样本中会出现某些属性值缺失的情况，鉴于完整的数据量并不是很多，因此不能简单的将缺失属性的样本剔除，而是采取适当的方法进行缺失值替换。除此以外，在计算过程中，会得到一些例如连铸正样含量比转炉终点含量要少，或者说计算出收得率大于1 的情况，对于这些数据样本，有可能是数据记录的过程中出现错误，或者是数据缺失值替换的不准确，或者是由于我们计算时假设前后钢水净重相同引起的，我们采取的方法是将这类样本剔除，用剩下的样本进行正常的计算以及后续模型的训练，验证。

	  总的来说，在第一问的过程中，我们的步骤分为：数据缺失值处理，收得率计算，收得率主要影响因素分析三步。

    \subsubsection{数据缺失值分析和替换}
    这一步的过程我们主要基于SPSS工具进行数据分析和缺失值替换。

先对转炉终点温度的缺失值进行补充对齐，转炉终点温度中数据缺失（数据为空或者为0）的占比只有5\%左右，由于这个属性的缺失样本比较少，所以直接采用了均值替换缺失数据的方法进行缺失值处理。

另外钢水净重的缺失值，由于缺失样本数量只有几个，所以也是直接用均值来替换缺失值。

接着对转炉终点C的缺失数据进行缺失值处理，数据缺失样本占比只有0.5\%左右，所以采用的方法也是均值替换缺失数据。
下一步是对转炉终点Mn的缺失数据进行分析处理，统计得转炉终点Mn的缺失数据达到86\%，缺失样本占比比较大，因为不能简单的进行均值替换，而且该属性数据是和样本序列位置并无直接关系，所以不能采取临近插值或者是线性趋势等方法进行缺失值替换。因此要对转炉终点Mn和其它变量的相关性分析，然后选取若干变量进行多重插补。

%【引用知乎https://zhuanlan.zhihu.com/p/22677693】
多值插补的思想来源于贝叶斯估计，认为待插补的值是随机的，它的值来自于已观测到的值。具体实践上通常是估计出待插补的值，然后再加上不同的噪声，形成多组可选插补值。根据某种选择依据，选取最合适的插补值。\cite{bibitem4}

多重插补方法分为三个步骤：①为每个空值产生一套可能的插补值，这些值反映了无响应模型的不确定性；每个值都可以被用来插补数据集中的缺失值，产生若干个完整数据集合。②每个插补数据集合都用针对完整数据集的统计方法进行统计分析。③对来自各个插补数据集的结果，根据评分函数进行选择，产生最终的插补值。

我们首先对转炉终点Mn和其它变量进行相关性分析，这里用到的相关性系数是皮尔逊相关系数。得到的结果如下表。

\setlength{\tabcolsep}{2mm}{
\begin{center}
\begin{tabular}{llll}
    \hline
    %\multicolumn{2}{|c|}{转炉终点Mn} \\
    %\hline
    \scriptsize 内容 & \scriptsize 皮尔逊相关性 & \scriptsize 内容 & \scriptsize 皮尔逊相关性 \\
    \hline
    \scriptsize 转炉终点Mn & \scriptsize 1 & \scriptsize 转炉终点温度 & \scriptsize 0.030   \\
    \scriptsize 转炉终点Si & \scriptsize 0.200** & \scriptsize 钢水净重 & \scriptsize 0.013   \\
    \scriptsize 转炉终点P & \scriptsize 0.530** & \scriptsize 连铸正样C & \scriptsize -0.017   \\
    \scriptsize 转炉终点S & \scriptsize -0.293**  & \scriptsize 连铸正样Mn & \scriptsize -0.009 \\
    \scriptsize 转炉终点C & \scriptsize 0.250**  & \scriptsize 连铸正样S & \scriptsize -0.176**  \\
    \scriptsize 钒铁（FeV50-A） & \scriptsize $.^a$  & \scriptsize 钒铁（FeV50-B）& \scriptsize $.^a$  \\
    \scriptsize 硅铝钙 & \scriptsize -0.088  & \scriptsize 硅铝合金FeAl30Si25 & \scriptsize -0.155*  \\
    \scriptsize 硅锰面（硅锰渣） & \scriptsize 0.73 & \scriptsize 硅铁（合格块） & \scriptsize $ .^a $ \\
    \scriptsize 石油焦增碳剂 & \scriptsize -0.236** & \scriptsize 碳化硅（55\%） & \scriptsize 0.091  \\
    \scriptsize 硅钙碳脱氧剂 & \scriptsize 0.194** & \scriptsize 锰硅合金FeMn64Si27（合格块） & \scriptsize 0.080 \\
    \scriptsize 连铸正样P & \scriptsize 0.426** & \scriptsize 连铸正样Si & \scriptsize -0.129* \\
    \scriptsize 氮化钒铁FeV55N11-A & \scriptsize 0.018 & \scriptsize 低铝硅铁 & \scriptsize 0.018 \\
    \scriptsize 钒氮合金 & \scriptsize -0.221** & \scriptsize 钒铁（FeV50-B） & \scriptsize 0.189** \\
    \scriptsize 硅铝锰合金球 & $ \scriptsize .^a $ & \scriptsize 硅铁FeSi75-B & \scriptsize -0.203** \\
    \scriptsize 锰硅合金FeMn68Si18（合格块） & \scriptsize -0.099 \\
    \hline
\end{tabular}
\end{center}}
\begin{center}
分析表：**.在0.01级别，相关性显著；*.在0.05级别，相关性显著 ；a.由于至少有一个变量为常量，因此无法进行计算
\end{center}

然后选取若干个和转炉终点Mn相关性较高的变量进行多重插补。经过一番思考及尝试，我们认为转炉终点Mn与转炉终点的C，P等其它元素的相关性是比较高的，因为同一炉钢水中元素含量间是有一定联系的，并且可以通过加入原料后的连铸正样进行反推出转炉终点Mn，并且考虑到连铸正样Mn和连铸正样C也有接近50\% 的缺失，所以一同进行多重插补，这样的话就可以同时对多个变量进行缺失值替换。并且使用了原料中的钒氮合金，钒铁B，硅铝合金，硅铁，石油焦增碳剂，硅钙碳脱氧剂进行多重插补。多重插补的模型以及插补结果如下表。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=7.5cm]{figure/p1_1.png}\\
  \caption{插补结果}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=9.5cm]{figure/p1_2.png}\\
  \caption{插补模型}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=15cm]{figure/p1_3.png}\\
  \caption{插补模型}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p1_4.png}\\
  \caption{插补模型}
\end{figure}

    \subsubsection{C，Mn元素收得率计算}
    通过上面的数据缺失值补充以后，我们就大致补全了计算收得率以及预测所要用到的变量数据了。接着就是计算收得率。

  对于收得率的计算，由于数据中并没有明确说明钢水重量是脱氧合金化前的钢水重量还是脱氧合金化后的钢水重量，所以我们假定脱氧合金化前后的钢水重量是不变的，然后通过前后的转炉终点和连铸正样数值进行计算出钢水中元素含量的差值，乘以钢水的质量就得到了脱氧合金化过程中钢水吸收元素重量。再通过加入的合金质量以及不同合金对应的元素成分重量百分比，计算出加入元素的重量，两者相除就得到了元素收得率。
\begin{equation}
\begin{aligned}
R_c=\frac{(x_8-x_2)x_7}{\sum_{i=0}^{15}x_{i+10}y_i^C}\\
R_{Mn}=\frac{(x_9-x_3)x_7}{\sum_{i=0}^{15}x_{i+10}y_i^{Mn}}
\end{aligned}
\end{equation}

在计算的过程中，因为数据不一定是准确的，可能是出于数据本身的记录错误或者是我们在进行缺失值补充的错误，都可能会造成计算收得率时的明显错误，因此在计算的时候我们会进行一些检查，不是有效的数据会直接剔除。例如说连铸正样元素含量低于转炉终点元素含量，或者说计算出的收得率大于1，这些情况的数据都会被剔除掉。在计算出C，Mn的元素收得率时会写入新的文件，用于后续模型的训练。

  整体数据（包括缺失值替换的数据，不包括异常数据）的平均C，Mn收得率大约在0.895，0.887。而C和Mn收得率计算过程中的有效样本个数为1314，1641个。
  前10个样本的收得率计算结果如下：

  \setlength{\tabcolsep}{2mm}{
\begin{center}
\begin{tabular}{llll}
    \hline
    \scriptsize 收得率 & \scriptsize 转炉终点 & \scriptsize 连铸正样 & \scriptsize 钢水净重 \\
    \hline
    \scriptsize 0.883 & \scriptsize 0.0011 & \scriptsize 0.0133 & \scriptsize 74400   \\
    \scriptsize 0.920 & \scriptsize 0.0011 & \scriptsize 0.0137 & \scriptsize 74200   \\
    \scriptsize 0.967 & \scriptsize 0.0011 & \scriptsize 0.0130 & \scriptsize 78250   \\
    \scriptsize 0.909 & \scriptsize 0.0012 & \scriptsize 0.0131 & \scriptsize 73600 \\
    \scriptsize 0.932 & \scriptsize 0.0009 & \scriptsize 0.0133 & \scriptsize 72400  \\
    \scriptsize 0.913 & \scriptsize 0.0007 & \scriptsize 0.0132 & \scriptsize 70350  \\
    \scriptsize 0.906 & \scriptsize 0.0012 & \scriptsize 0.0128 & \scriptsize 77800  \\
    \scriptsize 0.910 & \scriptsize 0.0014 & \scriptsize 0.0134 & \scriptsize 73050 \\
    \scriptsize 0.892 & \scriptsize 0.0009 & \scriptsize 0.0135 & \scriptsize 74300  \\
    \scriptsize 0.879 & \scriptsize 0.0011 & \scriptsize 0.0132 & \scriptsize 74850 \\
    \hline
\end{tabular}
\end{center}}
\begin{center}
Mn收得率计算结果
\end{center}


\setlength{\tabcolsep}{2mm}{
\begin{center}
\begin{tabular}{llll}
    \hline
    \scriptsize 收得率 & \scriptsize 转炉终点 & \scriptsize 连铸正样 & \scriptsize 钢水净重 \\
    \hline
    \scriptsize 0.913 & \scriptsize 0.00065 & \scriptsize 0.0023 & \scriptsize 74400   \\
    \scriptsize 0.866 & \scriptsize 0.00077 & \scriptsize 0.0023 & \scriptsize 74200   \\
    \scriptsize 0.867 & \scriptsize 0.00048 & \scriptsize 0.0022 & \scriptsize 78250   \\
    \scriptsize 0.979 & \scriptsize 0.00036 & \scriptsize 0.0024 & \scriptsize 73600 \\
    \scriptsize 0.970 & \scriptsize 0.00022 & \scriptsize 0.0023 & \scriptsize 72400  \\
    \scriptsize 0.915 & \scriptsize 0.00063 & \scriptsize 0.0023 & \scriptsize 70350  \\
    \scriptsize 0.692 & \scriptsize 0.00106 & \scriptsize 0.0022 & \scriptsize 77800  \\
    \scriptsize 0.998 & \scriptsize 0.00043 & \scriptsize 0.0024 & \scriptsize 73050 \\
    \scriptsize 0.973 & \scriptsize 0.00050 & \scriptsize 0.0023 & \scriptsize 74300  \\
    \scriptsize 0.914 & \scriptsize 0.00042 & \scriptsize 0.0023 & \scriptsize 74850 \\
    \hline
\end{tabular}
\end{center}}
\begin{center}
C收得率计算结果
\end{center}



\subsubsection{C，Mn收得率主要影响因素分析}
    接着是对收得率的影响主要因素的分析。首先要确定的影响变量应该是脱氧合金化前的变量以及加入的原料，而元素的连铸正样含量虽然会有相关性，但是从逻辑上来说不会是收得率的影响因素，因为收得率和连铸正样都是在脱氧合金化之后计算出来的。

	于是我们采用SPSS工具对收得率和其它上述变量间的相关性进行计算。

首先是C元素收得率的影响因素，通过计算皮尔逊相关系数和肯德尔相关系数进行相关性分析。通过综合两种相关系数结果可知，对C元素收得率的主要影响因素有转炉终点温度，转炉终点C，转炉终点Mn，钢水净重，以及加入合金中的低铝硅铁，钒氮合金(进口)，钒铁(FeV50-B)，硅铝钙，硅铝合金FeAl30Si25，硅铁(合格块)，锰硅合金FeMn68Si18(合格块)，硅钙碳脱氧剂。
\setlength{\tabcolsep}{2mm}{
\begin{center}
\begin{tabular}{lcc}
    \hline
    内容 & 皮尔逊相关系数 & 肯德尔tan\_b系数 \\
    C收得率 & 1 & 1 \\
    转炉终点温度 & 0.054* & 0.025 \\
    转炉终点C & -0.364** & -0.192**\\
    转炉终点Mn & -0.063*& -0.06**\\
    转炉终点S & 0.039& 0.025\\
    转炉终点P & -0.004& 0.014\\
    转炉终点Si & -0.023& -0.018\\
    钢水净重 & 0.359**& 0.253**\\
    氮化钒铁FeV55N11-A &-0.06* &-0.026 \\
    低硅铝铁 &-0.081** & -0.06**\\
    钒氮合金（进口） &-0.129** &-0.054* \\
    钒铁（FeV50-A）& 0.045& 0.044*\\
    钒铁（FeV50-B）& 0.107**& 0.069**\\
    硅铝钙 & 0.150**& 0.120**\\
    硅铝合金FeAl30Si25&-0.087** & -0.059**\\
    硅铝锰合金球 & 0.038& 0.036\\
    硅锰面（硅锰渣）& 0.005& 0.01\\
    硅铁（合格块）& -0.076**& -0.063**\\
    硅铁FeSi75-B &-0.021 & -0.011\\
    石油焦增碳剂 &0.02 & 0.024\\
    锰硅合金FeMn64Si27 &0.032 &0.028 \\
    锰硅合金FeMn68Si18 &-0.130** & -0.096**\\
    碳化硅（55\%） & 0.043& -0.037\\
    硅钙碳脱氧剂 &-0.99** & -0.076**\\
    \hline
\end{tabular}
\end{center}}
\begin{center}
分析表：**.在0.01级别，相关性显著；*.在0.05级别，相关性显著 ；a.由于至少有一个变量为常量，因此无法进行计算
\end{center}

然后是Mn元素收得率影响因素的分析，和C元素收得率分析方法相同。综合两种相关系数结果可知，对Mn元素收得率的主要影响因素有转炉终点Mn，转炉终点P，钢水净重，氮化钒铁FeV55N11-A，钒氮合金(进口)，硅铝钙，硅铝合金FeAl30Si25，硅铝锰合金球，硅钙碳脱氧剂，碳化硅(55\%)，锰硅合金FeMn68Si18(合格块)，硅铁FeSi75-B，硅锰面（硅锰渣）。

\setlength{\tabcolsep}{2mm}{
\begin{center}
\begin{tabular}{lcc}
    \hline
    内容 & 皮尔逊相关系数 & 肯德尔tan\_b系数 \\
    Mn收得率 & 1 & 1 \\
    转炉终点温度 & 0.023 &  0.031\\
    转炉终点C & -0.042 & -0.024\\
    转炉终点Mn &-0.261** & -0.205**\\
    转炉终点S & 0.013& 0.022\\
    转炉终点P & -0.094**& -0.07**\\
    转炉终点Si & -0.061*& -0.034\\
    钢水净重 & 0.462**& 0.338**\\
    氮化钒铁FeV55N11-A &-0.129** & -0.102**\\
    低硅铝铁 &0.003 & 0\\
    钒氮合金（进口） &0.129** & 0.083**\\
    钒铁（FeV50-A）& -0.021& -0.023\\
    钒铁（FeV50-B）& 0.029& 0.004\\
    硅铝钙 & -0.057*& -0.04*\\
    硅铝合金FeAl30Si25&0.083** & 0.08**\\
    硅铝锰合金球 & 0.051*& 0.054**\\
    硅锰面（硅锰渣）& -0.062*& -0.069**\\
    硅铁（合格块）&0.065** & 0.033\\
    硅铁FeSi75-B & 0.094**& 0.095**\\
    石油焦增碳剂 & 0.027& 0.027\\
    锰硅合金FeMn64Si27 & -0.012& -0.025\\
    锰硅合金FeMn68Si18 & -0.332**& -0.140**\\
    碳化硅（55\%） & -0.111**& -0.100**\\
    硅钙碳脱氧剂 & -0.062*& -0.063**\\
    \hline
\end{tabular}
\end{center}}
\begin{center}
分析表：**.在0.01级别，相关性显著；*.在0.05级别，相关性显著 ；a.由于至少有一个变量为常量，因此无法进行计算
\end{center}

针对以上的相关性结果进行分析，对元素收得率有影响的不仅有转炉终点温度，钢水质量这些可能会影响到化学反应的环境因素，针对不同的元素收得率，脱氧合金化前钢水中特定元素的含量，以及加入合金的种类也会影响到收得率。该元素本身的钢水含量以及加入含该元素较多的合金原料能够影响该元素收得率是可以想象得到的，而其它特定元素的含量以及含其它元素含量较多的合金原料至于为什么可以影响收得率，像Mn收得率中影响较大的元素有P，加入合金影响较大的合金中含有的V，Si又比较多，这些的影响可能是通过复杂的化学反应或者是催化作用实现的。


\newpage
\subsection{问题二}
\subsubsection{数据预处理}
1划分训练数据与测试数据
	这里我们将C的收得率（$R_c$）对应的数据和Mn收得率（$R_{Mn}$）对应的数据分开，分别训练输入数据对于它们的影响；对于数据我们对其进行划分，使用其中80\% 的数据进行训练，20\%的数据用来测试；并且对于训练数据和测试数据的划分是随机的（如果要对训练过程进行复现，固定其中的随机种子即可）。经过简单分析可知，所有元素的连铸正样对于元素收得率是没有影响的，因为元素的收得率正是根据其连铸正样的值计算而来的。换句话说，在已知所有的加入原料的情况下，对于连铸正样和收得率来说，知其一便可计算出另一值的大小。于是，对于C的收得率预测模型来说，输入的样本$X=(x_1,…x_7,x_{10},…,x_{25}), y = R_c$；我们的目的是训练出一个模型$predict_{R_c}$,使其接受一个样本$X_i$，能预测出出对应的$y_i$的值；对于Mn的收得率预测模型同样如此，预测出的模型为$predict_{R_{Mn}}$。可以想到，这是一个回归的问题，我们可以运用相关的回归模型解决这个问题。

2数据标准化：
在进行训练之前，要对数据进行标准化,。具体的方法就是，对于每一维的数据，将每一个数据减去这一个维度的平均值，再除以这个维度的标准差即可得到标准化之后的数据。标准化使得每一个维度的数据的尺度在一个数量级上，对于预测结果的贡献是相近的；此外，标准化还可以使得收敛路径更加平滑，减少的收敛过程中出现的“锯齿现象”，达到加快模型收敛的效果。

\subsubsection{模型选择}
这里我们选择了五种机器学习中常用的回归模型来进行训练，分别是随机森林回归（Random Forest Regression）\cite{bibitem5}，梯度增强回归（Gradient Boosting Regression）\cite{bibitem6}，多层感知器模型(Multi-Layer Perceptron)\cite{bibitem7}，线性回归(Linear Regression)\cite{bibitem8}和线性支持向量回归(Linear Support Vector Regression)模型\cite{bibitem9}。

	我们训练的结果如下，这里我们使用的是测试样本对训练好的模型进行测试。

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p1.png}\\
  \caption{C-predict-RandomForestRegressor}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p2.png}\\
  \caption{C-predict-GradientBoostingRegressor}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p3.png}\\
  \caption{C-predict-MLPRegressor}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p4.png}\\
  \caption{C-predict-LinearRegression}
\end{figure}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p5.png}\\
  \caption{C-predict-LinearSVR}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p6.png}\\
  \caption{Mn-predict-RandomForestRegressor}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p7.png}\\
  \caption{Mn-predict-GradientBoostingRegressor}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p8.png}\\
  \caption{Mn-predict-MLPRegressor}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/p9.png}\\
  \caption{Mn-predict-LinearRegression}
\end{figure}

\begin{figure}
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=12cm,height=8cm]{figure/p10.png}\\
  \caption{Mn-predict-LinearSVR}
\end{figure}


图其中横坐标为真实的收得率，而纵坐标为模型预测的收得率。图中的虚线为$y=x$；可以想到，若模型预测效果较好，则图中的点应当距离这条直线很近；若图中的点就位于这条直线上，那么模型对于这一个测试样本的预测效果是很好的，因为预测值与真实值完全相同；反之，如果一个点偏离$y=x$直线，那么模型对于这个样本的预测结果是不好的。通过对所有测试样本的观察，我们可以大致观察出哪个模型的预测值更加贴合真实值。

但是这还不够，为了更好的评价模型，我们对于每个模型分别计算其R2值；

$^{1-\frac {(\sum(y_i^*-y_i^-)^2)\/m}{(\sum(y_i-y_i^-)^2)\/m}}$  \\
其中$y_i^*$为预测值，$y_i^-$为平均值。

关于模型的R2值的求法，我们采用交叉验证的方法：将训练集分成5折(fold)；进行5次训练与与打分，其中第i次的训练过程中使用第i折的数据进行测试，使用其他4折的数据来训练；最终使用这5次得分的平均值做为模型的最终评分。这样可以更加全面客观的评价一个模型的好坏。
	
	对于这五种模型我们分别计算它们的R2值，效果如下：
\begin{figure}[htbp]
  \centering
  \includegraphics[width=12cm,height=8cm]{figure/R2-value-of-different-models.png}\\
  \caption{R2 value of different models}
\end{figure}
\newpage
\begin{table}

\begin{center}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Mn & 0.347 & 0.431 & 0.491 & 0.559 & 0.4995 \\
\hline
C & 0.710 & 0.790 & 0.759 & 0.842 & 0.440  \\
\hline
\end{tabular}
\end{center}
\end{table}
\begin{center}
  表：R2 value of different models
\end{center}

根据上面的对于预测值与真实值的比较以及计算具体的R2值后，我们发现线性回归模型在这个回归任务中取得了最好的效果。它不仅简单，计算高效，并且也易于训练，有较好的泛化能力。但是不足的地方就是线性回归模型的假设是每一个元素$x_i$对于y 的贡献是有其参数$\theta$决定的，而$\theta$总是有符号的；所以每一个元素对于最终的收得率的贡献要么为正作用，要么起到反作用。这样对于下面的优化是不利的，因为训练出的参数$\vec \theta$就可以决定优化的方向了。简单来说，如果起正作用就增加这种原料的含量，否则减少这种元素的含量。

\subsection{问题三}
\subsubsection{问题分析}
根据第二问的C，Mn元素收得率的预测模型，在符合国家钢铁元素含量标准的情况下对钢水脱氧化合金成本优化，并给出配料方案。

	模型的要求是在最小化成本的同时尽可能提高各个元素的收得率，并给出配料方案，并且在加入配料以后的钢水连铸正样元素含量要符合钢号对应的国家标准含量。

\subsubsection{模型假设}
	由于我们在第二问只建立了预测C和Mn的元素收得率预测模型，所以在第三问的模型中S，P，Si的收得率会设定为一个先验的常数。

	并且在计算的过程中和第一问一样会假设脱氧合金化前后钢水的净重没有发生变化。

\subsubsection{初步模型建立}
模型的求解变量是各个合金配料的加入重量。已知的变量是钢号，转炉终点温度，转炉终点C，转炉终点Mn，转炉终点S，转炉终点P，转炉终点Si，钢水净重。

我们根据合金配料加入重量以及附件2中的合金配料成本计算出脱氧合金化的成本，根据已知变量以及求解变量通过第二问的模型预测出C，Mn的收得率，（P，S，Si三种元素的收得率是设定的常数），接着加入的各元素总重量也可以通过配料加入重量以及附件2中各配料的元素重量百分比求出，就可以通过收得率乘以假如元素总重量求得钢水在脱氧合金化过程中吸收的元素重量，然后加上钢水中原有的元素百分比（转炉终点元素含量）就可以求出连铸正样元素含量，而这个连铸正样元素含量是要大于该钢号对应的国家元素含量标准的。

	综上所述，模型最小化目标函数：成本减元素收得率。约束函数主要是要使通过上述方法计算出的连铸正样元素含量大于钢号对应的国家元素含量标准。

\subsubsection{模型公式}



$\min \limits_{x_{10},x_{11},...,x_{25}} \{M-\lambda_1R_C - \lambda_2R_{Mn}\} $

\begin{equation}
s.t.\left\{
\begin{aligned}
&x_i \ge 0 ,i=10,...,16  \\
&x_i \le max_i  \\
&R_c\ge 0.75 \\
&R_{Mn} \ge 0.75 \\
&R_{c} \le 1 \\
&R_{Mn} \le 1 \\
&x_2+R_C\sum_{i=0}^{15}x_{i+10}y_i^C\ge B_{ID}^C  \\
&x_3+R_{Mn}\sum_{i=0}^{15}x_{i+10}y_i^{Mn}\ge B_{ID}^{Mn}  \\
&x_4+R_S\sum_{i=0}^{15}x_{i+10}y_i^S\ge B_{ID}^S  \\
&x_5+R_P\sum_{i=0}^{15}x_{i+10}y_i^P\ge B_{ID}^P  \\
&x_6+{R_Si}\sum_{i=0}^{15}x_{i+10}y_i^{Si}\ge B_{ID}^{Si}  \\
\end{aligned}
\right.
\end{equation}

其中,predict为第二问中的预测模型，$R_c = predict R_c(\vec x), \vec x=(x_1,x_2,...,x_7,x_{10},...,x_{16})$,\\
$R_{Mn} = predict R_{Mn}(\vec x), \vec x=(x_1,x_2,...,x_7,x_{10},...,x_{16})$,\\
$R_s,R_P,R_{Si}$设为常量值，$M=\sum_{i=0}^{15}x_{i+10}m_i$

\subsubsection{结果比较}
\begin{figure}
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=12cm,height=8cm]{figure/p3_1.png}\\
  \caption{优化前后成本比较（前十个样本）}
\end{figure}

\begin{figure}
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=12cm,height=8cm]{figure/p3_2.png}\\
  \caption{优化前后C收得率比较（前5个样本）}
\end{figure}

\begin{figure}
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=12cm,height=8cm]{figure/p3_3.png}\\
  \caption{优化前后Mn收得率比较（前5个样本）}
\end{figure}


\newpage
\subsection{问题四}
\begin{flushleft}
尊敬的炼钢厂领导：

	您好！
\end{flushleft}
我们是Mathorcup建模比赛的参赛学生，我们本次的题目是通过历史数据对脱氧合金化环节建立数学模型，在线预测合金收得率以及优化投入合金的种类以及数量，降低合金钢的生产成本。

	我们通过这次建模，首先意识到的就是数据的重要性。无论什么模型，在没有数据作为支撑的情况下都是难以立足的。或许在收集数据的过程中会在一定程度上增加空间或时间成本，但是通过这些数据建立的自动配料模型，在很长的一段时间内能够帮助企业进行合金配料的选择，不仅降低了成本，而且也能生产出更高质量的产品。

	另外，我们通过赛题提供的数据，建立了通过脱氧合金化前钢水的各种指标以及加入合金配料各项数据，对各个元素收得率进行预测的模型，这说明通过数学和计算机工具，我们可以在很大程度上在未进行真正脱氧合金化之前对收得率进行预测，进而通过先验知识，调整合金配料计划以达到较高的收得率。除此之外，我们还进一步建立了通过脱氧合金化前钢水的各种指标来提供合金配料方案的模型，并且这个方案是在满足标准的前提下所得到的最低成本。虽然用到的模型并不复杂，泛化能力和正确性可能也未做到尽善尽美，但是这也在一定程度证明了方法的可行性。
因此虽然难以建立完美的模型，但是模型能够帮助企业降低成本，并且在通过大量数据来求解出的配料方案中，一定程度上反应了不同配料间的催化，促进吸收等的复杂关系，而这些复杂关系仅通过理论研究是比较难掌握的。也就是说通过建立自动配料模型还可以帮助我们统计出配料规律，帮助我们进行配料方案验证以及提供大致方案的方向。

	最后，建立数学模型不仅仅是为了降低企业生产成本，从整个社会责任上来说，也是为了充分利用资源，减少合成过程中的残渣，废气等的排放，更好的保护生态环境，真正做到绿色可持续的高效发展。

	以上只是我们在这几天中的一些感悟，相信您所想到的一定会比我们更加长远和深入，只要牢牢把握住计算机技术辅助生产这个关键点，贵企业一定能够在竞争日趋激烈的形势下再创伟业，稳步健康持续的发展！\\
	敬祝\\
身体健康	\\
		
\begin{flushright}
  2019.4.15
\end{flushright}
												

\section{模型评价}

\subsection{优点}
第二问中的元素收得率预测模型：训练过程简易，泛化能力较强

第三问中的合金配料成本约束优化模型：能较好的给出合金配料方案，满足国家钢水元素含量标准，成本较数据中的方案而言降低了30%左右。

\subsection{缺点}
第二问中的元素收得率预测模型：难以对异常样本做出准确的预测

第三问中的合金配料成本约束优化模型：对初值设定敏感

\section{参考文献}
\begin{thebibliography}{a}
\bibitem{bibitem1} 作者：百度百科词条. 多元线性回归. \\
https://baike.baidu.com/item/\%E5\%A4\%9A\%E5\%85\%83\%E7 \\
\%BA\%BF\%E6\%80\%A7\%E5\%9B\%9E\%E5\%BD\%92/10702248?fr=aladdin. 
\bibitem{bibitem2} scikit learn.  Support Vector Machines. https://scikit-learn.org/dev/modules/svm.html. 
\bibitem{bibitem3}  周志华. 机器学习. 北京: 清华大学出版社,P403-P405 2016.
\bibitem{bibitem4} 作者：路上的你. 数据缺失值的4种处理方法.https://zhuanlan.zhihu.com/p/22677693. 
\bibitem{bibitem5} Andy Liaw and Matthew Wiener. Classification and Regression by randomForest.  \\
$https://www.researchgate.net/profile/Andy\_Liaw/publication/228451484\_Classification\_and  \\
\_Regression\_by\_RandomForest/links/53fb24cc0cf20a45497047ab/Classification-and-Regression-by-RandomForest.pdf$ 
\bibitem{bibitem6} Jerome H. Friedman. Greedy Function Approximation: A Gradient Boosting Machine. \\ $https://www.jstor.org/stable/2699986?seq=1\#metadata\_info\_tab\_contents$. 
\bibitem{bibitem7} E.Agirre-BasurkoaG.Ibarra-BerastegibI.Madariagac. Regression and multilayer perceptron-based models to forecast hourly O3 and NO2 levels in the Bilbao area.\\
     $https://www.sciencedirect.com/science/article/pii/S1364815204003056$. 
\bibitem{bibitem8} Douglas C. Montgomery， Elizabeth A. Peck， G. Geoffrey Vining. Introduction to Linear Regression Analysis. 
\bibitem{bibitem9} Alex J. SmolaBernhard Scholkop. A tutorial on support vector regression \\ https://link.springer.com/article/10.1023/BSTCO.0000035301.49549.88 
\end{thebibliography}


\begin{center}
  \large 附录\\
  代码语言:python
  含有中文的代码的部分被删掉了，详情请看附件
\end{center}

\begin{python}
import xlrd
import xlwt
import numpy as np
import os

def read_one_excel():
    ExcelFile=xlrd.open_workbook(r'C:\Users\artemis\Desktop\378328641fe895f045e76f2b43a2c3a31554942973066\test2.xlsx')
    sheet_name=ExcelFile.sheet_names()[0]
    sheet=ExcelFile.sheet_by_name(sheet_name)
    preC = sheet.col_values(4)[1:]
    preMn = sheet.col_values(5)[1:]
    waters = sheet.col_values(9)[1:]
    afterC = sheet.col_values(10)[1:]
    afterMn = sheet.col_values(11)[1:]
    materials = []
    materials.append(sheet.col_values(31)[1:])
    materials.append(sheet.col_values(33)[1:])
    materials.append(sheet.col_values(35)[1:])
    materials.append(sheet.col_values(36)[1:])
    materials.append(sheet.col_values(37)[1:])
    materials.append(sheet.col_values(38)[1:])
    materials.append(sheet.col_values(39)[1:])
    materials.append(sheet.col_values(40)[1:])
    materials.append(sheet.col_values(41)[1:])
    materials.append(sheet.col_values(42)[1:])
    materials.append(sheet.col_values(43)[1:])
    materials.append(sheet.col_values(44)[1:])

    return preC, preMn, waters, afterC, afterMn, materials

def read_two_excel():
    ExcelFile=xlrd.open_workbook(r'C:\Users\artemis\Desktop\378328641fe895f045e76f2b43a2c3a31554942973066\two.xlsx')
    sheet_name=ExcelFile.sheet_names()[0]
    sheet=ExcelFile.sheet_by_name(sheet_name)
    tempCpercent = sheet.col_values(1)[4:]
    tempMnpercent = sheet.col_values(2)[4:]
    Cpercent = tempCpercent[0:2]
    Cpercent.extend(tempCpercent[3:])
    Mnpercent = tempMnpercent[0:2]
    Mnpercent.extend(tempMnpercent[3:])
    return Cpercent, Mnpercent


preC, preMn, waters, afterC, afterMn, materials = read_one_excel()
Cpercent, Mnpercent = read_two_excel()
dataLen = len(preC)

isValidC = np.ones(dataLen)
isValidMn = np.ones(dataLen)

totalAddC = []
totalAddMn = []

for i in range(dataLen):
    tempC = 0
    tempMn = 0
    for j in range(len(materials)):
        tempC += materials[j][i] * Cpercent[j]
        tempMn += materials[j][i] * Mnpercent[j]

    totalAddC.append(tempC)
    totalAddMn.append(tempMn)

increC = []
increMn = []

for i in range(dataLen):
    if(isinstance(preC[i], str) or isinstance(afterC[i], str)):
        isValidC[i] = 0
        increC.append(-1)
    else:
        offsetC = afterC[i] - preC[i]
        if(offsetC < 0):
            isValidC[i] = 0
        increC.append(waters[i] * offsetC)
    if(isinstance(preMn[i], str) or isinstance(afterMn[i], str)):
        isValidMn[i] = 0
        increMn.append(-1)
    else:
        offsetMn = afterMn[i] - preMn[i]
        if(offsetMn < 0):
            isValidMn[i] = 0
        increMn.append(waters[i] * offsetMn)



print(sum(isValidC))
print(sum(isValidMn))

CgetRate = []
MngetRate = []
for i in range(dataLen):
    if isValidC[i] == 1:
        if increC[i] != 0 and totalAddC[i] == 0:
            isValidC[i] = 0
        else:
            if totalAddC[i] != 0 :
                temp = increC[i] / totalAddC[i]
            else:
                temp = 0

            if temp > 1:
                isValidC[i] = 0
            else:
                CgetRate.append(temp)
    if isValidMn[i] == 1:
        if increMn[i] != 0 and totalAddMn[i] == 0:
            isValidMn[i] = 0
        else:
            if totalAddMn[i] != 0 :
                temp = increMn[i] / totalAddMn[i]
            else:
                temp = 0
            if temp > 1:
                isValidMn[i] = 0
            else:
                MngetRate.append(temp)

print(sum(isValidC))
print(sum(isValidMn))

print(sum(CgetRate)/ len(CgetRate))
print(sum(MngetRate) / len(MngetRate))

def WriteSheetRow(sheet, rowValueList, rowIndex):
    i = 0
    for svalue in rowValueList:
        sheet.write(rowIndex, i, svalue)
        i = i + 1

workbook = xlwt.Workbook(encoding = 'ascii')
worksheet = workbook.add_sheet('My Worksheet')

def WriteSheetCol(sheet, ColValueList, ColIndex):
    i = 1
    for svalue in ColValueList:
        sheet.write(i, ColIndex, svalue)
        i = i + 1

workbook = xlwt.Workbook(encoding = 'ascii')
workbook2 = xlwt.Workbook(encoding = 'ascii')
worksheet = workbook.add_sheet('My Worksheet')
worksheet2 = workbook2.add_sheet('My Worksheet')

headList = ['1', '2', '3', '4', '5', '6', '7', '8',
            9', '10',	'11',	'12',	'13',	'14',
            '15'	, '16', '17',	'18',	'19',	'20','21',
            '22', '23',	'24',	'25',	'26',
            '27'	,'28', '29', '30'	, '31',
            '32', '33', '34', '35'	, '36',
            '37','38','39','40','41',
            '42','43'	,'44','45(55%)',
            '46']
WriteSheetRow(worksheet, headList, 0)
WriteSheetRow(worksheet2, headList, 0)

WriteSheetCol(worksheet, CgetRate, 0)
WriteSheetCol(worksheet2, MngetRate, 0)

ExcelFile=xlrd.open_workbook(r'C:\Users\artemis\Desktop\378328641fe895f045e76f2b43a2c3a31554942973066\test2.xlsx')
rowlen = len(headList) - 1
sheet_name=ExcelFile.sheet_names()[0]
sheet=ExcelFile.sheet_by_name(sheet_name)

for j in range(rowlen):
    temp = sheet.col_values(j)[1:]
    valid = []
    validMn = []
    for i in range(dataLen):
        if isValidC[i]:
            valid.append(temp[i])
        if isValidMn[i]:
            validMn.append(temp[i])
    WriteSheetCol(worksheet, valid, j + 1)
    WriteSheetCol(worksheet2, validMn, j + 1)

fileName = os.path.join(os.getcwd(),'CRate.xls')
fileName2 = os.path.join(os.getcwd(),'MnRate.xls')
workbook.save(fileName)
workbook2.save(fileName2)

\end{python}

\begin{python}
# -*- coding: utf-8 -*-
"""
Created on Thu Apr 11 20:46:03 2019

@author: zhangyzh36
"""

from sklearn import preprocessing;
import numpy as np;
import pandas as pd;
import matplotlib.pyplot as plt
import os
PATH = ''
num = 20

data = pd.read_excel("CRate.xls", encoding='gbk');


data = data.drop(columns=['steel_type','stove_num', 'steel_num', 'alloy4', 'C1', 'Mn1', 'S1', 'P1', 'Si1', 'Ceq_val', 'Cr_val', 'Ni_val', 'Nb_val', 'Cu_val', 'V_val', 'Alt_val',
                   'Als_val', 'Mo_val', 'Ti_val', 'N_val', 'O_val', 'B_val']);

X = data.iloc[:, 1:];
Y = data.iloc[:, 0:1];
from sklearn.cross_validation import train_test_split,cross_val_score
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2,  random_state=4)

from sklearn.preprocessing import StandardScaler
ss_x = StandardScaler()
X_train = ss_x.fit_transform(X_train)
X_test = ss_x.transform(X_test)





dataMn = pd.read_excel("MnRate.xls", encoding='gbk');


dataMn = dataMn.drop(columns=['steel_type','stove_num', 'steel_num', 'alloy4', 'C1', 'Mn1', 'S1', 'P1', 'Si1', 'Ceq_val', 'Cr_val', 'Ni_val', 'Nb_val', 'Cu_val', 'V_val', 'Alt_val',
                   'Als_val', 'Mo_val', 'Ti_val', 'N_val', 'O_val', 'B_val']);

XMn = dataMn.iloc[:, 1:];
YMn = dataMn.iloc[:, 0:1];
from sklearn.cross_validation import train_test_split,cross_val_score
X_trainMn, X_testMn, Y_trainMn, Y_testMn = train_test_split(XMn, YMn, test_size=0.2,  random_state=4)

from sklearn.preprocessing import StandardScaler
ss_xMn = StandardScaler()
X_trainMn = ss_xMn.fit_transform(X_trainMn)
X_testMn = ss_xMn.transform(X_testMn)

def try_different_method(model, name):
    model.fit(X_train,Y_train)
    scores = cross_val_score(model,X_train,Y_train,cv=5).ravel()
    score = np.mean(scores)
    print (scores)
    '''score = model.score(X_test, Y_test)'''
    result = model.predict(X_test)
    plt.figure()
    plt.plot(np.arange(len(result)), Y_test,'go-',label='true value')
    plt.plot(np.arange(len(result)),result,'ro-',label='predict value')
    plt.title(name + ' score: %f'%score)
    plt.legend()
    plt.show()

def try_different_method_Mn(model, name):
    model.fit(X_trainMn,Y_trainMn)
    scores = cross_val_score(model,X_trainMn,Y_trainMn,cv=5).ravel()
    score = np.mean(scores)
    print (scores)
    '''score = model.score(X_test, Y_test)'''
    result = model.predict(X_testMn)
    plt.figure()
    plt.plot(np.arange(len(result)), Y_testMn,'go-',label='true value')
    plt.plot(np.arange(len(result)),result,'ro-',label='predict value')
    plt.title(name + ' score: %f'%score)
    plt.legend()
    plt.show()


from sklearn.linear_model import LinearRegression
model_LinearRegression = LinearRegression();

from sklearn.svm import SVR
model_linear_SVR1 = SVR(kernel='linear')
model_linear_SVR2 = SVR(kernel='linear')
model_rbf_SVR = SVR(kernel='rbf')
model_poly_SVR = SVR(kernel='poly')

from sklearn.neighbors import KNeighborsRegressor
model_KNeighborsRegressor = KNeighborsRegressor()

from sklearn.ensemble import RandomForestRegressor
model_RandomForestRegressor = RandomForestRegressor(n_estimators=100)

from sklearn.ensemble import AdaBoostRegressor
model_AdaBoostRegressor = AdaBoostRegressor(n_estimators=50)

from sklearn.ensemble import GradientBoostingRegressor
model_GradientBoostingRegressor = GradientBoostingRegressor(n_estimators=250)

from sklearn.ensemble import BaggingRegressor
model_BaggingRegressor = BaggingRegressor()

from sklearn.tree import ExtraTreeRegressor
model_ExtraTreeRegressor = ExtraTreeRegressor()

from sklearn.neural_network import MLPRegressor
model_MLPRegressor = MLPRegressor(solver='lbfgs', alpha=1e-5,hidden_layer_sizes=(100, 8), random_state=1);



'''
try_different_method(model_AdaBoostRegressor, 'AdaBoot')
try_different_method(model_poly_SVR, 'poly SVR')
try_different_method(model_KNeighborsRegressor, 'knn')
try_different_method(model_RandomForestRegressor, 'randomForest')
try_different_method(model_BaggingRegressor, 'Bagging')
try_different_method(model_ExtraTreeRegressor, 'ExtraTree')
'''


'''third que'''


third_model = model_linear_SVR1
third_modelMn = model_linear_SVR2
'''
third_model = model_linear_SVR1
third_modelMn = model_linear_SVR2
'''


data_for_third = pd.read_excel("third-data.xls")
iron_water_data = data_for_third.iloc[:, 3:10].values
ironId = data_for_third.iloc[:,2]
ids = ['HRB400B', 'HRB400D', 'Q345B', 'HRB500D', 'HRB500B', '20MnKA', '20MnKB', 'Q235A', 'Q235']
percentages = [[0.19, 0.5, 1.3, 0.04, 0.04],
              [0.19, 1.3, 0.04, 0.04, 0.37],
              [0.16, 0.75, 0.015, 0.025, 0.2],
              [0.25, 1.6, 0.045, 0.045, 0.8],
              [0.25, 1.6, 0.045, 0.045, 0.8],
              [0.21, 1.2, 0.045, 0.045, 0.2],
              [0.21, 1.2, 0.045, 0.045, 0.2],
              [0.15, 0.3, 0.025, 0.035, 0.12],
              [0.15, 0.3, 0.025, 0.035, 0.12]]


original_material = data_for_third.iloc[:, 28:32].values
a = data_for_third.iloc[:,33:45].values
original_material = np.hstack((original_material, a))


index = 3
delta = 0.0001;

import xlrd
def minMaterials(args):
  id = ironId[index]
  idIndex = ids.index(id)
  percentage = percentages[idIndex][0]
  testx = np.concatenate((iron_water_data[index], args))

  testx = np.array([testx])
  testx = ss_x.transform(testx)
  rate = third_model.predict(testx)


  ExcelFile=xlrd.open_workbook(r'two.xlsx')
  sheet_name=ExcelFile.sheet_names()[0]
  sheet=ExcelFile.sheet_by_name(sheet_name)
  cpercent = sheet.col_values(1)[1:]
  add = sum(rate * (cpercent * args))
  water = iron_water_data[index][6]
  add = add / water
  origin = iron_water_data[index][1]
  add = origin + add


  return add - percentage * 0.01

def minMaterialsMn(args):
  id = ironId[index]
  idIndex = ids.index(id)
  percentage = percentages[idIndex][1]
  testx = np.concatenate((iron_water_data[index], args))

  testx = np.array([testx])
  testx = ss_x.transform(testx)
  rate = third_model.predict(testx)


  ExcelFile=xlrd.open_workbook(r'two.xlsx')
  sheet_name=ExcelFile.sheet_names()[0]
  sheet=ExcelFile.sheet_by_name(sheet_name)
  Mnpercent = sheet.col_values(2)[1:]
  add = sum(rate * (Mnpercent * args))
  water = iron_water_data[index][6]
  add = add / water
  origin = iron_water_data[index][2]
  add = origin + add

  return add - percentage * 0.01


SRate = 0.9
PRate = 0.9
SiRate = 0.9

def minMaterialsS(args):
  id = ironId[index]
  idIndex = ids.index(id)
  percentage = percentages[idIndex][2]
  rate = SRate

  ExcelFile=xlrd.open_workbook(r'two.xlsx')
  sheet_name=ExcelFile.sheet_names()[0]
  sheet=ExcelFile.sheet_by_name(sheet_name)
  Spercent = sheet.col_values(3)[1:]
  add = sum(rate * (Spercent * args))
  water = iron_water_data[index][6]
  add = add / water
  origin = iron_water_data[index][3]
  add = origin + add

  return add - percentage* 0.01

def minMaterialsP(args):
  id = ironId[index]
  idIndex = ids.index(id)
  percentage = percentages[idIndex][3]
  rate = PRate

  ExcelFile=xlrd.open_workbook(r'two.xlsx')
  sheet_name=ExcelFile.sheet_names()[0]
  sheet=ExcelFile.sheet_by_name(sheet_name)
  Ppercent = sheet.col_values(4)[1:]
  add = sum(rate * (Ppercent * args))
  water = iron_water_data[index][6]
  add = add / water
  origin = iron_water_data[index][4]
  add = origin + add

  return add - percentage* 0.01

def minMaterialsSi(args):
  id = ironId[index]
  idIndex = ids.index(id)
  percentage = percentages[idIndex][4]
  rate = SiRate


  ExcelFile=xlrd.open_workbook(r'two.xlsx')
  sheet_name=ExcelFile.sheet_names()[0]
  sheet=ExcelFile.sheet_by_name(sheet_name)
  Sipercent = sheet.col_values(5)[1:]
  add = sum(rate * (Sipercent * args))
  water = iron_water_data[index][6]
  add = add / water
  origin = iron_water_data[index][5]
  add = origin + add

  return add - percentage* 0.01


third_model.fit(X_train,Y_train)
third_modelMn.fit(X_trainMn, Y_trainMn)


cost = np.array([350.000, 6.500, 350.000, 205.000, 205.000, 11.800, 1.000, 8.500, 7.600, 6.000, 6.000, 4.600, 8.150, 8.150, 6.100, 4.000])
maximun = np.array([50, 163, 82, 48, 325, 100, 125, 300, 300, 200, 210, 127, 1600, 3100, 176, 25]);
from scipy.optimize import minimize
def func(args):
    args = np.array(args)

    testx = np.concatenate((iron_water_data[index], args))

    testx = np.array([testx])
    testx = ss_x.transform(testx)
    rate = third_model.predict(testx)
    MnRate = third_modelMn.predict(testx)

    money = np.dot(np.array(args), cost)
    result = money - rate * 1e3 - MnRate * 5e4


    return result

cons = ({'type': 'ineq',
         'fun' : lambda x: np.array([x[0] - delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[1] - delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[2]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[3]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[4]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[5]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[6]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[7]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[8]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[9]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[10]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[11]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[12]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[13]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[14]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([x[15]- delta])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[0] - x[0]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[1] - x[1]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[2] - x[2]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[3] - x[3]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[4] - x[4]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[5] - x[5]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[6] - x[6]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[7] - x[7]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[8] - x[8]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[9] - x[9]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[10] - x[10]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[11] - x[11]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[12] - x[12]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[13] - x[13]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[14] - x[14]])},
         {'type': 'ineq',
         'fun' : lambda x: np.array([maximun[15] - x[15]])},
         {'type': 'ineq',
         'fun' : lambda x:  third_model.predict(ss_x.transform(np.array([np.concatenate((iron_water_data[index], x))])))[0] - 0.75},
         {'type': 'ineq',
         'fun' : lambda x:  third_modelMn.predict(ss_x.transform(np.array([np.concatenate((iron_water_data[index], x))])))[0] - 0.75},
         {'type': 'ineq',
         'fun' : lambda x:  0.99 - (third_model.predict(ss_x.transform(np.array([np.concatenate((iron_water_data[index], x))])))[0])},
         {'type': 'ineq',
         'fun' : lambda x:  0.99 - (third_modelMn.predict(ss_x.transform(np.array([np.concatenate((iron_water_data[index], x))])))[0])},
          {'type': 'ineq',
         'fun' : lambda x: minMaterials(x) - delta},
          {'type': 'ineq',
         'fun' : lambda x: minMaterialsMn(x) - delta},
         {'type': 'ineq',
         'fun' : lambda x: minMaterialsS(x) - delta},
        {'type': 'ineq',
         'fun' : lambda x: minMaterialsSi(x) - delta},
         {'type': 'ineq',
         'fun' : lambda x: minMaterialsP(x) - delta},
         )

x0 = np.array((10.0, 0.47, 6.78, 1.53, 26.79, 23.91, 10.19, 0.68, 51.92, 2.80, 5.69, 76.42, 0, 1500.41, 104.67, 0.0))

ExcelFile=xlrd.open_workbook(r'two.xlsx')
sheet_name=ExcelFile.sheet_names()[0]
sheet=ExcelFile.sheet_by_name(sheet_name)


import xlwt
workbook = xlwt.Workbook(encoding = 'ascii')
worksheet = workbook.add_sheet('My Worksheet')

def WriteSheetRow(sheet, rowValueList, rowIndex):
    i = 0
    for svalue in rowValueList:
        sheet.write(rowIndex, i, svalue)
        i = i + 1

workbook = xlwt.Workbook(encoding = 'ascii')
worksheet = workbook.add_sheet('My Worksheet')

headList = ['1', '2', '3', '4', '5',
            '6', '7',	'8',	'9', '10',
            '11', '12', '13'	, '14',
            '15','16','17','18','19',
            '20','21'	,'22','23',
            '24', '25','26', '27', '28','29',
            '30','31', '32', '33','34', '35','36']

WriteSheetRow(worksheet, headList, 0)


for index in range(num):
    res = minimize(func, x0, args=(), constraints=cons, method='SLSQP', options={'disp': True})
    materialRes = np.round(res.x)
    water_data = iron_water_data[index]
    money = np.dot(np.array(materialRes), cost)
    original_money = np.dot(np.array(original_material[index]), cost)
    MnRate = third_modelMn.predict(ss_x.transform(np.array([np.concatenate((iron_water_data[index], materialRes))])))[0]
    CRate = third_model.predict(ss_x.transform(np.array([np.concatenate((iron_water_data[index], materialRes))])))[0]
    target = []


    water = iron_water_data[index][6]
    id = ironId[index]
    idIndex = ids.index(id)
    percentage = percentages[idIndex]


    Cpercent = sheet.col_values(1)[1:]
    add = sum(CRate * (Cpercent * materialRes))
    add = add / water
    origin = iron_water_data[index][1]
    add = origin + add
    target.append(add)


    Mnpercent = sheet.col_values(2)[1:]
    add = sum(MnRate * (Mnpercent * materialRes))
    add = add / water
    origin = iron_water_data[index][2]
    add = origin + add
    target.append(add)


    for i in range(3):
        percent = sheet.col_values(i+3)[1:]
        add = sum(PRate * (percent * materialRes))
        add = add / water
        origin = iron_water_data[index][i+3]
        add = origin + add
        target.append(add)

    rowValue = []
    rowValue.append(id)
    rowValue.extend(water_data)
    rowValue.extend(materialRes)
    rowValue.append(CRate)
    rowValue.append(MnRate)
    rowValue.append(SRate)
    rowValue.append(PRate)
    rowValue.append(SiRate)
    rowValue.extend(target)
    rowValue.append(money)
    rowValue.append(original_money)
    WriteSheetRow(worksheet, rowValue, index + 1)

import os
fileName = os.path.join(os.getcwd(),'third-plan.xls')
workbook.save(fileName)

\end{python}


\end{document}{center}




